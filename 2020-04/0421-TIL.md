애플리케이션을 상태머신이라고 부른다.

Input -> Process -> Output 의 형태로 동작

</br>

브라우저의 동작은 사용자가 입력하는 URL을 통해 input을 받고, 화면상에 output을 보여주는 것.

</br>

### 변수

---

: `하나의 값을 저장`하기 위해 확보한 <u>메모리 공간</u> 자체  또는 그 메모리 공간을 <u>식별하기 위해 붙인 이름</u>

</br>

> 메모리와 데이터
>
> : 메모리는 데이터를 저장할 수 있는 셀들의 집합체이다.
>
> 셀 하나의 크기는 1byte(8bit)이며 2진수로 표현된다. 
>
> 데이터로서 의미를 가지려면 최소 8bit가 필요하다는 얘기.
>
> 각각의 셀은 고유의 메모리 주소(memory address)를 가진다.
>
> 메모리는 기억만 할 뿐, CPU가 행위를 수행하는 것. 
>
> 메모리는 제한된 자원이기때문에 할당된(예약된) 메모리가 많아지면 동작이 느려질 수 있다.

</br></br>

변수는 **데이터 관리**의 핵심 개념이다.

변수는 많아지면 오류가 발생할 확률이 커진다.

불필요한 변수는 제외하고 <u>필요한 변수만을 선언</u>해야한다.

</br></br>

#####  변수가 필요한 이유?

: 데이터가 임의의 메모리 공간(위치)에 저장되기 때문에 주소를 기억하지 않으면 재 접근이 불가능하다.

  메모리 값에 직접 접근하는 것은 시스템적 오류를 유발할 수 있다.

  또한 값이 저장되는 메모리의 위치는 임의로 지정되기 때문에 변동될 수 있다.(주소에 대한 확신x)

  때문에 식별자(변수명)를 이용해 메모리 주소를 기억해서 사용하는 것.

</br></br>

```
var result = 1 + 2;
는 1 + 2 라는 식 자체로 메모리에 저장되는 것이 아니다.
1이 저장된 공간이 있고, 2가 저장된 공간이 있고
1 + 2 = 3 이라는 연산의 결과인 3이 저장된 공간이 존재한다.
그리고 result 라는 변수는 3이 저장된 메모리 셀의 주소를 기억하는 것.
```

</br></br></br>

#### 변수 선언

---

```
var result = 10 + 20; 에서

var 은 키워드
result 는 변수이름
10 과 20 은 리터럴
+ 는 연산자 
10 + 20 은 표현식 
```

> 키워드란? 컴퓨터와 약속한 명령어. var, switch, for, break, function.. 

</br>

자바스크립트 엔진은 변수 선언을 2단계를 거쳐 수행한다.

- 선언 단계(Declaration phase) : 변수 이름을 등록하여 존재 선언
- 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간 확보 & undefined 값 할당(원시타입의 값)

```
var x = 1; 

var x  // 변수 x 선언
x = 1 // 변수 x에 1의 값을 할당 

-> x에 할당된 값이 없는데 x를 구하면 undefined. 
-> x가 선언되지 않았는데 접근하면 ReferenceError(참조에러)
```

> 변수이름은 어디에 등록되는가?
>
> '실행 컨텍스트(execution context)' 내에 key / value 형식인 객체로 등록되어 관리된다.
>
> 실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역.

</br></br></br>

#### 변수 선언의 실행시점과 변수 호이스팅(Variable Hoisting )

---

변수의 선언은 런타임(Run-time) 이전에 실행된다. 

때문에 변수의 선언이 상단에 있지 않더라도 위치에 상관없이 변수를 참조할 수 있다.

</br>

```
console.log(x);  // undefined
var x = 30;

// x의 선언이 실행문 하단에 있음에도 불구하고 실행문은 참조에러가 아닌 undefined값을 받고 있다. 
// 자바스크립트는 변수 선언시 초기화를 해주지 않았더라도 
// 암묵적으로 초기화(undefined라는 값을 할당해주는 것 => var에만 해당)를 해준다.
// 원래는 초기화하지 않은 변수를 참조하면 쓰레기 값(메모리에 저장된 의미없는 데이터값)이 나올 수 있다.
// 선언문인 var x; 가 할당문인 x = 30;이 실행(run-time)되기 전에 실행된다.
```

이러한 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작**하는 것을 **변수 호이스팅**이라고 한다.

실제로 코드가 끌어올려 지는 것이 아닌, 먼저 실행하는 것.

자바스크립트는 런타임 이전에 소스코드 전체를 파싱하고 선언문만 먼저 실행하게 된다.

> 호이스팅은 변수뿐 아니라 let, const, function,class.. 와 같은 식별자 선언문 전부 해당된다. 

</br></br></br>

#### 변수 값의 재할당

---

var 키워드로 선언한 변수는 재할당이 가능하다. (ES6의 `const`는 재할당이 금지된 상수)

```
var x = 10;
x = 20;
x = 30;
console.log(x);
// 변수 x의 값은 30이다. 
```

위와 같이 변수 x의 값을 재할당함으로써 불필요하게된  10과 20은  `가비지 컬렉터`에 의해 기존 변수 x와의 관계가 해제(release)된다. 

```
var result; 가 가리키는 메모리 셀의 주소(초기화 값인 undefined)와
result = 20; 이 가리키는 메모리 셀의 주소가 다르다.
result에 값을 재할당했을때 result는 기존 확보(name-binding)된 주소(undefined)를 해제하고 새로 할당된 30이란 값이 저장된 메모리 주소를 가리키게 된다.
```

</br>

`가비지 컬렉터(Garbage Collector)`란?

: 어플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 불필요한 값을 찾아내 기존 확보된 주소(name-binding)를 해제하는 기능. 불필요한 값을 지우는 게 아니다. 새로 다른 동작을 하며 해당 메모리 공간은 덮어쓰기때문에 지울 필요가 없다. 

  자바스크립트는 가비지 컬렉터를 내장한 `매니지드 언어` 이다. 

  반면에 메모리 관리를 개발자가 주관하는 `언매니지드 언어`에는 C, C++이 있다. 

</br>

재할당은 가급적 안하는 게 좋다.

자바스크립트는 타입이 없다.

>  var number = 1; 이라고 하면 변수명 이외에 숫자라는 의미를 말해줄 수 없다. var는 그저 variable일뿐.. 또한 var number에는 1 이외에도 문자열이나 불리언 값도 들어갈 수 있다.

때문에 재할당 후 참조하여 사용했을 시 타입이 달라 발생할 수 있는 오류 확률이 높다. 

</br></br></br>

#### 식별자란?

---

- 어떤 값을 구별하기 위해 지정한 고유한 이름 (변수, 상수등에 붙인다)
- 변수뿐 아니라 함수도 식별자를 지정할 수 있다.
- '선언'하면 식별자인 것이라고 이해하면 쉽다.

</br></br></br>

#### 식별자 네이밍 규칙

---

- 식별자는 특수문자를 제외한 문자, 언더스코어( _ ), 달러사인( $ )을 포함할 수 있다.
- 식별자는 숫자로 시작할 수 없다. 
- `예약어`는 식별자로 사용할 수 없다.
- 대소문자를 구분한다.
- 사용하는 의미가 담긴 이름으로 선언해야한다. (ex. var score, var topBtn..)

</br>

`예약어(reserved word)` 란?

: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어들.

  ex) await, break, case, catch, class, continue.. 

</br></br>

##### ! 네이밍 컨벤션

```
var firstName; // 카멜 케이스(camelCase) 
var first_name; // 스네이크 케이스(snake_case)
var FirstName; // 파스칼 케이스(PascalCase)

// 헝가리언 케이스(typeHungarianCase)
var strFirstName;  // type + identifier 타입을 함께 명시해주는 방식
var $elem = $('.myClass'); //jQuery
```

일반적으로 변수나 함수의 이름엔 *카멜 케이스*

생성자 함수, 클래스의 이름에는 *파스칼 케이스*

</br></br></br></br>

### 표현식과 문

---

####  값?

- 표현식(expression)이 평가(evaluate)되어 생성된 결과 
- 변수에 할당할 수 있으면 다 값. (값은 표현식의 결과물)
- 모든 값은 데이터 타입을 가진다

> 데이터 타입은 크게 1. 원시타입 2. 객체타입 으로 나눌 수 있다.
>
> 원시값 : 변경 불가능(immutable)
>
> 객체 : 변경가능(mutable)
>
> > 여기서 변경이란? 
> >
> > 값을 입력했을 때, 메모리 셀의 주소가 바뀌지 않은 상태에서 해당 메모리의 값이 바뀌는 것.
> >
> > 재할당을 하면 새 메모리 셀에 값을 입력하므로 메모리 주소의 값이 반드시 변한다.
> >
> > 원시값은 재할당을 해야 값을 변경할 수 있는 철칙이 있다.
> >
> > 객체는 재할당 없이도 값을 교체하는 것. 그때문에 상태 변화의 여부는 잘 모를 수 있다. 

</br>

```
var x = 10;  // 10 이라는 값으로 평가된다. 10은 리터럴이자 표현식이자 값.
```

</br></br>

#### 리터럴?

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 <u>표기방식(notation)</u>
- 값으로 평가될 수 있는 <u>표현식 그 자체</u> 

``` 
//정수 리터럴
100
// 부동 소숫점 리터럴
10.5
// 정수와 부동소숫점은 다른건데 자바스크립트는 정수까지 부동 소숫점으로 동작한다. 

// 2진수 리터럴(0b로 시작)
0b01000001
// 이외에 8진수, 16진수 리터럴 존재

//문자열 리터럴
'hello'
//불리언 리터럴
true
//null 리터럴 (undefined도 리터럴)
null
// 객체 리터럴
{ name : 'lee', address : 'seoul'}
// 배열 리터럴
[ 1, 2, 3 ]
// 함수 리터럴
function() {}
```

\+ [정규식 리터럴 참고]([https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/정규식))

</br></br>

#### 표현식?

- 표현식(expression)은 값으로 표현될 수 있는 문(statement)이다.
- 즉, **값으로 평가될 수 있는 문**은 다 표현식.

```
// 리터럴 표현식
10 
'hello'
// 식별자 표현식 ( 선언이 이미 존재한다고 가정 )
sum
person.name
// 연산자 표현식
10 + 20
// 함수/메소드 호출 표현식 ( 선언이 이미 존재한다고 가정 )
square()
```

```
var x = 1;
을 브라우저 콘솔창에 썼을 때 undefined가 뜬다. 
콘솔창은 기본적으로 평가(실행)한 결과를 띄워주는데,
= 연산자는 기본적으로 양쪽의 값을 비교해주는 것이다.
var x; 와 x = 1;로 구성되었기 때문에 
var x는 선언문이므로 undefined가 뜨게 되는 것.
->  var x 는 표현식(값으로 평가될 수 있는 문)이 아닌 완료값이다. 


값이 위치할 수 있는 곳에는 표현식이 올 수 있다. 
 x = 2 를치면
2가 할당문이자 표현식이므로 콘솔에 2라는 결과값이 출력된다.
```

</br>

값으로 표현될 수 없는 문은 표현식이 아니다. (ex. 선언문 - var x;)

이를 완료 값(completion value)이라고 한다. undefined를 출력.

완료값은 다른 값과 같이 변수에 할당할 수 없다. (ex. var x = var y;)

> 파싱은 코드 전체에 동작되는 것
>
> 실행은 평가보다 큰 개념
>
> 평가는 목적이 될 수 있으므로, 평가하기 위해 실행한다고 할 수도 있다.
>
> 값이 나오지 않은 것은 실행했다고 할 수 있다.(ex.선언문)

</br></br>

#### 문?

- 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위

- 컴퓨터에 내리는 명령(선언문, 할당문, 조건문, 반복문..)

- 문들이 모여 프로그램을 이룬다.

- 토큰들로 구성되어있다.

  > `토큰(token)`이란?
  >
  >  문법적인 의미를 가지며, 문법적으로 더 나눌 수 없는 코드의 기본 요소
  >
  >  ex) 키워드, 연산자, 식별자, 리터럴, 세미콜론(;) .. 

- 문은 세미콜론( ; )으로 끝난다. 

  생략가능(Automatic Semeicolon insertion 동작)하지만 붙이는 걸 권장. 

  > 자체 종결성을 갖는 `코드블록` 에는 세미콜론( ; )을 붙이지 않는다.
  >
  > ex)   - { .. } 중괄호로 묶은 코드블록
  >
  > ​		- if 문, for 문, 함수 등의  코드블록

</br></br>