### 변수

---

: `하나의 값을 저장`하기 위해 확보한 <u>메모리 공간</u> 자체  또는 그 메모리 공간을 <u>식별하기 위해 붙인 이름</u>

</br>

> 메모리와 데이터
>
> : 메모리는 데이터를 저장할 수 있는 셀들의 집합체이다.
>
>   셀 하나의 크기는 1byte(8bit)이며 2진수로 표현된다. 
>
>   각각의 셀은 고유의 메모리 주소(memory address)를 가진다.
>
>   CPU가 이 값을 읽어내고 수행하는 것. 

</br></br>

#####  변수가 필요한 이유?

: 데이터가 임의의 메모리 공간(위치)에 저장되기 때문에 주소를 기억하지 않으면 재 접근이 불가능하다.

  메모리 값에 직접 접근하는 것은 시스템적 오류를 초래하기때문에,

  식별자(변수)를 이용해 메모리 주소를 기억하는 것.

</br></br></br>

#### 변수 선언

---

자바스크립트 엔진은 변수 선언을 2단계를 거쳐 수행한다.

- 선언 단계(Declaration phase) : 변수 이름을 등록하여 존재 선언
- 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간 확보 & undefined 값 할당(원시타입의 값)

```
var x = 1;

var x  // 변수 x 선언
x = 1 // 변수 x에 1의 값을 할당 

-> x에 할당된 값이 없는데 x를 구하면 undefined. 
-> x가 선언되지 않았는데 접근하면 ReferenceError(참조에러)
```

</br></br></br>

#### 변수 선언의 실행시점과 변수 호이스팅(Variable Hoisting )

---

변수의 선언은 런타임(Run-time) 이전에 실행된다. 

때문에 변수의 선언이 상단에 있지 않더라도 위치에 상관없이 변수를 참조할 수 있다.

</br>

```
console.log(x);  // undefined
var x;

// x의 선언이 실행문 하단에 있음에도 불구하고 실행문은 참조에러가 아닌 undefined값을 받고 있다. 
```

이러한 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작**하는 것을 **변수 호이스팅**이라고 한다.

> 호이스팅은 변수뿐 아니라 let, const, function,class.. 와 같은 식별자 선언문 전부 해당된다. 

</br></br></br>

#### 변수 값의 재할당

---

var 키워드로 선언한 변수는 재할당이 가능하다. (ES6의 `const`는 재할당이 금지된 상수)

```
var x = 10;
x = 20;
x = 30;
console.log(x);
// 변수 x의 값은 30이다. 
```

위와 같이 변수 x의 값을 재선언 함으로써 버려진 10과 20은 불필요한 값으로 `가비지 컬렉터`에 의해 메모리에서 해제(release)된다. 

`가비지 컬렉터(Garbage Collector)`란?

: 어플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 불필요한 값을 메모리에서 해제하는 기능.

  자바스크립트는 가비지 컬렉터를 내장한 `매니지드 언어` 이다. 

  반면에 메모리 관리를 개발자가 주관하는 `언매니지드 언어`에는 C, C++이 있다. 

</br></br></br>

#### 식별자 네이밍 규칙

---

- 식별자는 특수문자를 제외한 문자, 언더스코어( _ ), 달러사인( $ )을 포함할 수 있다.
- 식별자는 숫자로 시작할 수 없다. 
- `예약어`는 식별자로 사용할 수 없다.
- 대소문자를 구분한다.
- 사용하는 의미가 담긴 이름으로 선언해야한다. (ex. var score, var topBtn..)

</br>

`예약어(reserved word)` 란?

: 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어들.

  ex) await, break, case, catch, class, continue.. 

</br></br>

##### ! 네이밍 컨벤션

```
var firstName; // 카멜 케이스(camelCase) 
var first_name; // 스네이크 케이스(snake_case)
var FirstName; // 파스칼 케이스(PascalCase)

// 헝가리언 케이스(typeHungarianCase)
var strFirstName;  // type + identifier 타입을 함께 명시해주는 방식
var $elem = $('.myClass'); //jQuery
```

일반적으로 변수나 함수의 이름엔 *카멜 케이스*

생성자 함수, 클래스의 이름에는 *파스칼 케이스*

</br></br></br></br>

### 표현식과 문

---

####  값?

- 표현식(expression)이 평가(evaluate)되어 생성된 결과 

- 모든 값은 데이터 타입을 가진다

</br></br>

#### 리터럴?

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기방식(notation)
- 값으로 평가될 수 있는 <u>표현식 그 자체</u> 

``` 
//정수 리터럴
100
//문자열 리터럴
'hello'
//불리언 리터럴
true
//null 리터럴 (undefined도 리터럴)
null
// 객체 리터럴
{ name : 'lee', address : 'seoul'}
// 배열 리터럴
[ 1, 2, 3 ]
// 함수 리터럴
function() {}
```

\+ [정규식 리터럴 참고](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/정규식)

</br></br>

#### 표현식?

- 표현식(expression)은 값으로 표현될 수 있는 문(statement)이다.

```
// 리터럴 표현식
10 
'hello'
// 식별자 표현식 ( 선언이 이미 존재한다고 가정 )
sum
person.name
// 연산자 표현식
10 + 20
// 함수/메소드 호출 표현식 ( 선언이 이미 존재한다고 가정 )
square()
```

- 값으로 표현될 수 없는 문은 표현식이 아니다. (ex. 선언문 - var x;)

  이를 완료 값(completion value)이라고 한다. undefined를 출력.

  완료값은 다른 값과 같이 변수에 할당할 수 없다. (ex. var x = var y;)

</br></br>

#### 문?

- 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위

- 컴퓨터에 내리는 명령(선언문, 할당문, 조건문, 반복문..)

- 문들이 모여 프로그램을 이룬다.

- 토큰들로 구성되어있다.

  > `토큰(token)`이란?
  >
  >  문법적인 의미를 가지며, 문법적으로 더 나눌 수 없는 코드의 기본 요소
  >
  >  ex) 키워드, 연산자, 식별자, 리터럴, 세미콜론(;) .. 

- 문은 세미콜론( ; )으로 끝난다. 

  생략가능(Automatic Semeicolon insertion 동작)하지만 붙이는 걸 권장. 

  > 자체 종결성을 갖는 `코드블록` 에는 세미콜론( ; )을 붙이지 않는다.
  >
  > ex)   - { .. } 중괄호로 묶은 코드블록
  >
  > ​		- if 문, for 문, 함수 등의  코드블록

</br></br>